<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Created by GNU Texinfo 6.8, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- This manual is for fswatch (version 1.17.0,
23 June 2022), a cross-platform file change monitor with multiple
backends: Apple macOS File System Events, *BSD kqueue,
Solaris/Illumos File Events Notification, Linux inotify,
Microsoft Windows ReadDirectoryChangesW and a
stat()-based backend.

Copyright (C) 2013-2021 Enrico M. Crisostomo

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3
or any later version published by the Free Software Foundation;
with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
Texts. A copy of the license is included in the section entitled "GNU
Free Documentation License". -->
<title>Tutorial Introduction to fswatch (fswatch 1.17.0)</title>

<meta name="description" content="Tutorial Introduction to fswatch (fswatch 1.17.0)">
<meta name="keywords" content="Tutorial Introduction to fswatch (fswatch 1.17.0)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Index-of-Functions.html" rel="index" title="Index of Functions">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="index.html" rel="up" title="Top">
<link href="Invoking-fswatch.html" rel="next" title="Invoking fswatch">
<link href="Introduction.html" rel="prev" title="Introduction">
<style type="text/css">
<!--
a.copiable-anchor {visibility: hidden; text-decoration: none; line-height: 0em}
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
span:hover a.copiable-anchor {visibility: visible}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="en">
<div class="chapter" id="Tutorial-Introduction-to-fswatch">
<div class="header">
<p>
Next: <a href="Invoking-fswatch.html" accesskey="n" rel="next">Invoking <code>fswatch</code></a>, Previous: <a href="Introduction.html" accesskey="p" rel="prev">Introduction</a>, Up: <a href="index.html" accesskey="u" rel="up">fswatch</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index-of-Functions.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<span id="Tutorial-Introduction-to-fswatch-1"></span><h2 class="chapter">3 Tutorial Introduction to <code>fswatch</code></h2>
<span id="index-tutorial"></span>
<p>This chapter is a tutorial walk-through on the most common use cases
where <code>fswatch</code> is useful:
</p>
<ul>
<li> Detecting file system changes.
</li><li> Observing file system changes.
</li><li> Processing <code>fswatch</code> output.
</li></ul>

<ul class="section-toc">
<li><a href="#Detecting-File-System-Changes" accesskey="1">Detecting File System Changes</a></li>
<li><a href="#Observing-File-System-Changes-1" accesskey="2">Observing File System Changes</a></li>
<li><a href="#Processing-fswatch-Output" accesskey="3">Processing <code>fswatch</code> Output</a></li>
<li><a href="#Detecting-the-Boundaries-of-a-Batch-of-Changes" accesskey="4">Detecting the Boundaries of a Batch of Changes</a></li>
<li><a href="#Receiving-a-Single-Event" accesskey="5">Receiving a Single Event</a></li>
</ul>
<div class="section" id="Detecting-File-System-Changes">
<h3 class="section">3.1 Detecting File System Changes</h3>
<span id="index-changes_002c-detecting"></span>
<span id="index-fswatch_002c-bulk-mode"></span>
<p>A common use case is <em>detecting</em> file system changes in a set of
file system objects<a id="DOCF1" href="#FOOT1"><sup>1</sup></a> where
the <em>details</em> of a change are irrelevant.  This mode of operation
is called <em>bulk mode</em> and <code>fswatch</code> will only dump a
single event record per batch<a id="DOCF2" href="#FOOT2"><sup>2</sup></a>  containing the number
of affected file system objects.  No other details are avaible in the
event record.
</p>
<span id="index-rsync"></span>
<p>The most common application of this mode of operation is performing a
bulk action on all the observed file system objects, such as a
synchronization with <code>rsync</code>, which will serve us as an
example.  In this case, a change event triggers the execution of a
synchronization script, no matter the event type kind nor the object
the event affects.
</p>
<p>To run <code>fswatch</code> in batch mode, the (<samp>-o</samp>,
<samp>--one-per-batch</samp>) must be used:
</p>
<div class="example">
<pre class="example">$ fswatch -o <var>path</var> ...
2
10
</pre></div>

<p>The (<samp>-l</samp>, <samp>--latency</samp>) option can be used to set the
latency according to the requirements:
</p>
<div class="example">
<pre class="example">$ fswatch -o -l 5 <var>path</var> ...
4
7
</pre></div>

<p>This way, you can respond to change events in a way which is (or can
easily be) path-independent (because you are not receiving any event
detail) and you prefer to &lsquo;bubble&rsquo; events together to reduce the
overhead of the command being executed.
</p>
<p>In bulk mode the output of <code>fswatch</code> is guaranteed to have the
following structure:
</p>
<div class="example">
<pre class="example"><var>number</var>\n
</pre></div>

<p><span id="index-read"></span>
<span id="index-xargs-1"></span>
where &lsquo;<samp>number</samp>&rsquo; is an integer value and &lsquo;<samp>\n</samp>&rsquo; is the new line
character.  A line with this structure is very easy to read with
either <code>xargs</code> or the <code>read</code> builtin:
</p>
<div class="example">
<pre class="example">$ fswatch -o <var>path</var> | while read <var>num</var> ; \
  do \
    ... \
  done
</pre></div>

<p>In many scripts of this kind, the <var>num</var> variable can even be
ignored.
</p>
</div>
<div class="section" id="Observing-File-System-Changes-1">
<h3 class="section">3.2 Observing File System Changes</h3>
<span id="Observing-File-System-Changes"></span><span id="index-changes_002c-observing"></span>
<span id="index-fswatch_002c-main-mode"></span>
<p>Besides the batch mode, <code>fswatch</code> provides a <em>main</em> mode
providing the full change events details and the file system objects
they refer to.  The main mode is <code>fswatch</code>&rsquo;s <em>default</em>
mode of operation and needs no specific flags to be activated.
</p>
<p>In this mode, <code>fswatch</code> outputs change events to the standard
output.  By default, only the affected file name is printed and the
change event record structure has the following structure:
</p>
<div class="example">
<pre class="example"><var>path</var>\n
</pre></div>

<p>where <var>path</var> is the full path of the changed file system object.
</p>
<p><code>fswatch</code> lets users customize the format of the event record
and the information it includes.  For example:
</p>
<ul>
<li> <span id="index-timestamp_002c-add"></span>
The event <em>timestamp</em> can be added.

</li><li> <span id="index-event-mask_002c-add"></span>
The event mask can be added in either textual or numerical form.

</li><li> <span id="index-record_002c-format"></span>
The event record can be defined using a <code>printf</code>-like format
string.

</li></ul>

<ul class="section-toc">
<li><a href="#Event-details" accesskey="1">Event details</a></li>
<li><a href="#Parseability-Issues" accesskey="2">Parseability Issues</a></li>
<li><a href="#Numeric-Event-Flags-1" accesskey="3">Numeric Event Flags</a></li>
</ul>
<div class="subsection" id="Event-details">
<h4 class="subsection">3.2.1 Event details</h4>
<p>Beside the full path of the change object, details on the kind of
change event can be obtained using the (<samp>-x</samp>,
<samp>--event-flags</samp>) option:
</p>
<div class="example">
<pre class="example">$ fswatch -xr <var>/path/to/observe</var>
/path/to/observe Created Renamed OwnerModified IsFile
...
</pre></div>

<p>In this case, a space-separated list of change flags are printed after
the path of the changed object.  The record structure is thus:
</p>
<div class="example">
<pre class="example">/absolute-path flag ( flag)*
</pre></div>

<p>where &lsquo;<samp>flag</samp>&rsquo; is an event flag.  At least one event flag is always
present, and additional ones are &lsquo;bubbled&rsquo; into the same record and
separated by space.  For more information on event flags see <a href="Invoking-fswatch.html#Event-Flags">Event Flags</a>.
</p>
</div>
<div class="subsection" id="Parseability-Issues">
<h4 class="subsection">3.2.2 Parseability Issues</h4>
<span id="index-parseability"></span>
<span id="index-record_002c-parsing"></span>
<p>The default record format is intuitive and human-readable.  However,
since a Unix file name may contain any character but the path
separator &lsquo;<samp>/</samp>&rsquo; and the &lsquo;<samp>NUL</samp>&rsquo;<a id="DOCF3" href="#FOOT3"><sup>3</sup></a> character, it suffers from two classes of
parseability issues:
</p>
<ul>
<li> The default choice of using &lsquo;<samp>\n</samp>&rsquo; as record separator may lead to
unexpected results because a file name can legally contain &lsquo;<samp>\n</samp>&rsquo;.
<span id="index-find"></span>
<span id="index-xargs-2"></span>
For this reason, along the line of what other tools such as
<code>find</code> and <code>xargs</code> already do, the &lsquo;<samp>NUL</samp>&rsquo;
character (&lsquo;<samp>\0</samp>&rsquo;) can alternatively be used:

<div class="example">
<pre class="example">/absolute-path( flag)*\0
</pre></div>

</li><li> Since a file name may contain spaces, this record structure is not
unambigually parseable if more than one event flag is present: in this
case, any subset <em class='math'>[0, x], x &lt; n - 1</em> of the <em class='math'>n</em> event flags
may be part or the file name and hence any parse result would be
indeterminate.

</li></ul>

<p>Both issues can be solved using a custom record format (see <a href="Invoking-fswatch.html#Custom-Record-Formats">Custom Record Formats</a>).
</p>
</div>
<div class="subsection" id="Numeric-Event-Flags-1">
<h4 class="subsection">3.2.3 Numeric Event Flags</h4>
<span id="index-event_002c-flags"></span>
<span id="index-event_002c-flags_002c-numeric"></span>
<p>Instead of using user-friendly event flag <em>names</em>, as seen in the
previous section, <em>numeric</em> event flags can be used instead.
Currently, the real advantage this method offers, despite possibly
cleaner flag-decoding logic, is the availability of a non-ambigous
event record representation.
</p>
<p>To instruct <code>fswatch</code> to print numeric event flags, the
(<samp>-n</samp>, <samp>--numeric</samp>) option must be used:
</p>
<div class="example">
<pre class="example">$ fswatch -xnr <var>/path/to/observe</var>
/absolute-path 2058
</pre></div>

<p>The numeric event flag value is the bitwise OR of the individual event
flag values, that are powers of 2.  In the previous example, the flag
<em class='math'>2058</em> is decomposed in powers of 2 as <em class='math'>2058 = 2048 + 8 + 2
= 2^{11} + 2^3 + 2</em>, that is, the first, the third and the eleventh
event flags.
</p>
</div>
</div>
<div class="section" id="Processing-fswatch-Output">
<h3 class="section">3.3 Processing <code>fswatch</code> Output</h3>
<span id="index-record_002c-parsing-1"></span>
<span id="index-record_002c-piping"></span>
<p>Very often you wish to not only receive an event, but also react to
it.  The simplest way to do it is piping the output of
<code>fswatch</code> to another process.  Since in Unix and Unix-like
file system file names may potentially contain any character but
&lsquo;<samp>NUL</samp>&rsquo; (&lsquo;<samp>\0</samp>&rsquo;) and the path separator (&lsquo;<samp>/</samp>&rsquo;),
<code>fswatch</code> has a specific mode of operation when its output
must be piped to another process.  When the (<samp>-0</samp>,
<samp>--print0</samp>) option is used, <code>fswatch</code> will use the
&lsquo;<samp>NUL</samp>&rsquo; character as record separator, thus allowing any other
character to appear in a path.
<span id="index-read-1"></span>
This is important because many commands and shell builtins (such as
<code>read</code>) split lines using the newline character (&lsquo;<samp>\n</samp>&rsquo;)
and words using the characters in <code>$IFS</code>, which by default
contains characters which may be present in a file name, resulting in
a wrong event path being received and processed.
</p>
<span id="index-xargs-3"></span>
<p>The simplest way to pipe <code>fswatch</code>&rsquo;s output to another program
is using <code>xargs</code>:
</p>
<div class="example">
<pre class="example">$ fswatch -0 (<var>opts</var>)* (<var>paths</var>)+ | xargs -0 -n 1 -I {} <var>command</var>
</pre></div>

<p>The command in this example does the following:
</p>
<ul>
<li> <code>fswatch -0</code> will split records using the &lsquo;<samp>NUL</samp>&rsquo;
character.

</li><li> <code>xargs -0</code> will split records using the &lsquo;<samp>NUL</samp>&rsquo; character.
This is required to correctly match impedance with <code>fswatch</code>.

</li><li> <code>xargs -n 1</code> will invoke <code><var>command</var></code> every record.  If
you want to do it every <code><var>x</var></code> records, then use <code>xargs
-n <var>x</var></code>.

</li><li> <code>xargs -I {}</code> will substitute occurrences of <code>{}</code> in
<code><var>command</var></code> with the parsed argument.  If the command you are
running does not need the event path name, just delete this option.
If you prefer using another replacement string, substitute <code>{}</code>
with another string of your choice.
</li></ul>

</div>
<div class="section" id="Detecting-the-Boundaries-of-a-Batch-of-Changes">
<h3 class="section">3.4 Detecting the Boundaries of a Batch of Changes</h3>
<span id="index-batch-marker"></span>
<span id="index-batch_002dmarker_002c-detail"></span>
<p>If a process or script is piped to <code>fswatch</code> output, sometimes
it would be desirable to detect the &lsquo;boundaries&rsquo; of a batch of
changes.  This way, the process receiving the stream of changes would
rely on the timings imposed by the latency settings of
<code>fswatch</code> to start a phase of events <em>processing</em> after a
phase or events <em>gathering</em>.  The <samp>--batch-marker</samp> option
can be used to accomplish this task:
</p>
<div class="example">
<pre class="example">$ fswatch --batch-marker -r ~
/home/fswatch/.zsh_history.LOCK
NoOp
/home/fswatch/.zsh_history.new
/home/fswatch/.zsh_history
/home/fswatch/.zsh_history.LOCK
NoOp
</pre></div>

<p>In this example, the &lsquo;<samp>NoOp</samp>&rsquo; records mark the end of the 1 second
batches of events output by <code>fswatch</code>.  The batch marker can
be customized.  For more information <a href="Invoking-fswatch.html#Batch-Marker">Batch Marker</a>.
</p>
</div>
<div class="section" id="Receiving-a-Single-Event">
<h3 class="section">3.5 Receiving a Single Event</h3>
<span id="index-single-event"></span>
<span id="index-one_002devent_002c-detail"></span>
<p>Another feature of <code>fswatch</code> is the possibility of receiving a
<em>single</em> event and exit.  This is most useful when existing
scripts processing events include the restart logic of
<code>fswatch</code>.  This use case is implemented by the <samp>-1</samp>,
<samp>--one-event</samp> option:
</p>
<div class="example">
<pre class="example">$ fswatch -1 /path/to/watch
/path/to/watch/child0
/path/to/watch/child1
...
$
</pre></div>

</div>
</div>
<div class="footnote">
<hr>
<h4 class="footnotes-heading">Footnotes</h4>

<h5><a id="FOOT1" href="#DOCF1">(1)</a></h5>
<p>In the context of this manual (unless
specified otherwise), <em>file system object</em> refers undistinctively
to <em>files</em>, <em>directories</em> and <em>symbolic links</em>.</p>
<h5><a id="FOOT2" href="#DOCF2">(2)</a></h5>
<p>A <em>batch</em> is an iteration
of <code>fswatch</code> scanning logic, whose frequency is <em class='math'>\nu =
l^{-1}</em>, where <em class='math'>l</em> is the <em>latency</em>.</p>
<h5><a id="FOOT3" href="#DOCF3">(3)</a></h5>
<p>Depending on the file
system being used, other restrictions may apply.  However, for file
system portability reasons, you should consider &lsquo;<samp>NUL</samp>&rsquo; as the only
forbidden character.</p>
</div>
<hr>
<div class="header">
<p>
Next: <a href="Invoking-fswatch.html">Invoking <code>fswatch</code></a>, Previous: <a href="Introduction.html">Introduction</a>, Up: <a href="index.html">fswatch</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index-of-Functions.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
